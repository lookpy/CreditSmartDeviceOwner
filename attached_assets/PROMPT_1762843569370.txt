# Diagn√≥stico e Solu√ß√£o - Problema de Conectividade APK
## CDC CreditSmart - Erro de DNS Resolution

---

## üî¥ PROBLEMA IDENTIFICADO

```
‚ùå Unable to resolve host "cdccreditsmart.com": No address associated with hostname
```

O APK n√£o consegue resolver o DNS do dom√≠nio `cdccreditsmart.com` no dispositivo Android.

---

## üîç Diagn√≥stico Completo

### Sintomas Observados nos Logs

```
2025-11-11 03:42:07.890  MdmCommandReceiver  ‚ùå WebSocket MDM FALHOU!
2025-11-11 03:42:07.890  MdmCommandReceiver  ‚ùå Erro: Unable to resolve host "cdccreditsmart.com": No address associated with hostname
```

**Componentes Afetados:**
1. ‚ùå WebSocketManager (`/ws/flow-status`)
2. ‚ùå MdmCommandReceiver (`/ws` - comandos MDM)
3. ‚ùå CdcForegroundService

**Tentativas de Reconex√£o:**
- ‚úÖ Reconex√£o autom√°tica a cada 5 segundos (implementada)
- ‚úÖ Polling fallback iniciado (30s)
- ‚ùå Todas falhando por DNS

---

## üõ†Ô∏è SOLU√á√ïES

### Solu√ß√£o 1: For√ßar DNS P√∫blico no Android (RECOMENDADA)

Configure DNS p√∫blico (Google ou Cloudflare) no OkHttpClient:

```kotlin
import okhttp3.Dns
import java.net.InetAddress

// Custom DNS resolver usando Google DNS (8.8.8.8 / 8.8.4.4)
object CustomDns : Dns {
    private val googleDns1 = InetAddress.getByName("8.8.8.8")
    private val googleDns2 = InetAddress.getByName("8.8.4.4")
    private val cloudflareDns = InetAddress.getByName("1.1.1.1")
    
    override fun lookup(hostname: String): List<InetAddress> {
        try {
            // Tentar resolver usando DNS padr√£o primeiro
            return Dns.SYSTEM.lookup(hostname)
        } catch (e: UnknownHostException) {
            Log.w("CustomDns", "Falha no DNS padr√£o para $hostname, tentando DNS p√∫blico...")
            
            // Fallback: tentar resolver manualmente usando Google DNS
            try {
                val addresses = mutableListOf<InetAddress>()
                
                // Usar DnsResolver do Android 10+ se dispon√≠vel
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    // Usar API moderna de DNS
                    val dnsResolver = android.net.DnsResolver.getInstance()
                    // Implementar lookup ass√≠ncrono aqui
                }
                
                // Fallback: IP hardcoded se necess√°rio (N√ÉO RECOMENDADO)
                // addresses.add(InetAddress.getByName("34.111.179.208"))
                
                return if (addresses.isNotEmpty()) addresses 
                       else Dns.SYSTEM.lookup(hostname) // √öltima tentativa
                       
            } catch (e2: Exception) {
                Log.e("CustomDns", "Todos os m√©todos de DNS falharam", e2)
                throw e // Re-throw original exception
            }
        }
    }
}

// Aplicar no OkHttpClient
val okHttpClient = OkHttpClient.Builder()
    .dns(CustomDns) // ‚Üê ADICIONAR ISTO
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .addInterceptor(loggingInterceptor)
    .build()
```

### Solu√ß√£o 2: Fallback para IP Direto (TEMPOR√ÅRIA)

**‚ö†Ô∏è APENAS PARA TESTE - N√ÉO USAR EM PRODU√á√ÉO**

```kotlin
object ApiConfig {
    // Endere√ßo IP direto do servidor (obtido via nslookup)
    const val FALLBACK_IP = "34.111.179.208"
    const val PRIMARY_URL = "https://cdccreditsmart.com"
    const val FALLBACK_URL = "https://$FALLBACK_IP"
    
    // Tentar URL prim√°ria, se falhar usar IP
    fun getBaseUrl(): String {
        return try {
            // Testar conectividade
            InetAddress.getByName("cdccreditsmart.com")
            PRIMARY_URL
        } catch (e: UnknownHostException) {
            Log.w("ApiConfig", "DNS falhou, usando IP direto")
            FALLBACK_URL
        }
    }
}

// Usar no Retrofit
val retrofit = Retrofit.Builder()
    .baseUrl(ApiConfig.getBaseUrl())
    .build()
```

**Problema desta abordagem:**
- ‚ùå SSL pode falhar (certificate mismatch)
- ‚ùå IP pode mudar sem aviso
- ‚ùå N√£o √© escal√°vel

### Solu√ß√£o 3: Verificar Permiss√µes de Rede

Garanta que o APK tem todas as permiss√µes necess√°rias:

**AndroidManifest.xml:**

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    
    <!-- Permiss√µes de Rede -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    
    <!-- Para Android 9+ (clear text traffic) -->
    <application
        android:usesCleartextTraffic="true"
        android:networkSecurityConfig="@xml/network_security_config">
    </application>
    
</manifest>
```

**res/xml/network_security_config.xml:**

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <!-- Permitir clear text traffic para desenvolvimento -->
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
    
    <!-- Configura√ß√£o espec√≠fica para cdccreditsmart.com -->
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">cdccreditsmart.com</domain>
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </domain-config>
</network-security-config>
```

### Solu√ß√£o 4: Implementar Cache DNS Local

```kotlin
object DnsCache {
    private val cache = mutableMapOf<String, List<InetAddress>>()
    private val cacheTTL = 5 * 60 * 1000L // 5 minutos
    private val cacheTimestamp = mutableMapOf<String, Long>()
    
    fun resolve(hostname: String): List<InetAddress> {
        val now = System.currentTimeMillis()
        val cached = cache[hostname]
        val timestamp = cacheTimestamp[hostname] ?: 0L
        
        // Se cache v√°lido, retornar
        if (cached != null && (now - timestamp) < cacheTTL) {
            Log.d("DnsCache", "‚úÖ Usando DNS em cache para $hostname")
            return cached
        }
        
        // Resolver novo
        return try {
            val addresses = InetAddress.getAllByName(hostname).toList()
            cache[hostname] = addresses
            cacheTimestamp[hostname] = now
            Log.d("DnsCache", "‚úÖ DNS resolvido e em cache: $hostname ‚Üí ${addresses.size} endere√ßos")
            addresses
        } catch (e: UnknownHostException) {
            Log.e("DnsCache", "‚ùå Falha ao resolver $hostname", e)
            // Retornar cache expirado se existir
            cached ?: throw e
        }
    }
}

// Usar no CustomDns
object CustomDns : Dns {
    override fun lookup(hostname: String): List<InetAddress> {
        return DnsCache.resolve(hostname)
    }
}
```

---

## üß™ DIAGN√ìSTICO DE CONECTIVIDADE

Adicione estas fun√ß√µes de diagn√≥stico ao APK para identificar o problema:

```kotlin
object ConnectivityDiagnostics {
    
    fun checkNetworkConnectivity(context: Context): NetworkStatus {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        
        val activeNetwork = connectivityManager.activeNetwork
        val networkCapabilities = connectivityManager.getNetworkCapabilities(activeNetwork)
        
        return NetworkStatus(
            isConnected = networkCapabilities != null,
            hasInternet = networkCapabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true,
            hasValidated = networkCapabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) == true,
            transportType = when {
                networkCapabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true -> "WiFi"
                networkCapabilities?.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) == true -> "Cellular"
                networkCapabilities?.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) == true -> "Ethernet"
                else -> "Unknown"
            }
        )
    }
    
    fun testDnsResolution(hostname: String): DnsResult {
        val startTime = System.currentTimeMillis()
        
        return try {
            val addresses = InetAddress.getAllByName(hostname)
            val endTime = System.currentTimeMillis()
            
            DnsResult(
                success = true,
                hostname = hostname,
                resolvedAddresses = addresses.map { it.hostAddress ?: "unknown" },
                responseTime = endTime - startTime,
                error = null
            )
        } catch (e: UnknownHostException) {
            val endTime = System.currentTimeMillis()
            
            DnsResult(
                success = false,
                hostname = hostname,
                resolvedAddresses = emptyList(),
                responseTime = endTime - startTime,
                error = e.message
            )
        }
    }
    
    fun testHttpConnectivity(url: String): HttpResult {
        val startTime = System.currentTimeMillis()
        
        return try {
            val client = OkHttpClient.Builder()
                .connectTimeout(10, TimeUnit.SECONDS)
                .build()
            
            val request = Request.Builder()
                .url(url)
                .head() // Apenas HEAD request
                .build()
            
            val response = client.newCall(request).execute()
            val endTime = System.currentTimeMillis()
            
            HttpResult(
                success = response.isSuccessful,
                url = url,
                statusCode = response.code,
                responseTime = endTime - startTime,
                error = if (!response.isSuccessful) response.message else null
            )
        } catch (e: Exception) {
            val endTime = System.currentTimeMillis()
            
            HttpResult(
                success = false,
                url = url,
                statusCode = null,
                responseTime = endTime - startTime,
                error = e.message
            )
        }
    }
    
    fun runFullDiagnostics(context: Context): DiagnosticsReport {
        Log.i("Diagnostics", "üîç Iniciando diagn√≥stico completo de conectividade...")
        
        val networkStatus = checkNetworkConnectivity(context)
        Log.i("Diagnostics", "üì° Rede: ${networkStatus.transportType}, Internet: ${networkStatus.hasInternet}")
        
        val dnsTest = testDnsResolution("cdccreditsmart.com")
        Log.i("Diagnostics", "üåê DNS: ${if (dnsTest.success) "‚úÖ Sucesso" else "‚ùå Falhou"}")
        if (dnsTest.success) {
            Log.i("Diagnostics", "   IPs: ${dnsTest.resolvedAddresses.joinToString()}")
        } else {
            Log.e("Diagnostics", "   Erro: ${dnsTest.error}")
        }
        
        val httpTest = testHttpConnectivity("https://cdccreditsmart.com/api/health")
        Log.i("Diagnostics", "üåç HTTP: ${if (httpTest.success) "‚úÖ Sucesso" else "‚ùå Falhou"}")
        if (httpTest.success) {
            Log.i("Diagnostics", "   Status: ${httpTest.statusCode}, Tempo: ${httpTest.responseTime}ms")
        } else {
            Log.e("Diagnostics", "   Erro: ${httpTest.error}")
        }
        
        return DiagnosticsReport(
            timestamp = System.currentTimeMillis(),
            networkStatus = networkStatus,
            dnsTest = dnsTest,
            httpTest = httpTest
        )
    }
}

data class NetworkStatus(
    val isConnected: Boolean,
    val hasInternet: Boolean,
    val hasValidated: Boolean,
    val transportType: String
)

data class DnsResult(
    val success: Boolean,
    val hostname: String,
    val resolvedAddresses: List<String>,
    val responseTime: Long,
    val error: String?
)

data class HttpResult(
    val success: Boolean,
    val url: String,
    val statusCode: Int?,
    val responseTime: Long,
    val error: String?
)

data class DiagnosticsReport(
    val timestamp: Long,
    val networkStatus: NetworkStatus,
    val dnsTest: DnsResult,
    val httpTest: HttpResult
)
```

### Usar o Diagn√≥stico

```kotlin
// No onCreate do MainActivity ou CdcForegroundService
lifecycleScope.launch(Dispatchers.IO) {
    val report = ConnectivityDiagnostics.runFullDiagnostics(applicationContext)
    
    if (!report.networkStatus.isConnected) {
        Log.e("Diagnostics", "‚ùå Sem conex√£o de rede!")
    }
    
    if (!report.dnsTest.success) {
        Log.e("Diagnostics", "‚ùå DNS n√£o resolve - problema identificado!")
        Log.e("Diagnostics", "   Considere usar DNS p√∫blico (8.8.8.8)")
    }
    
    if (!report.httpTest.success) {
        Log.e("Diagnostics", "‚ùå HTTP n√£o conecta - firewall ou backend offline!")
    }
}
```

---

## üì± COMANDOS ADB PARA TESTE

Se tiver acesso via ADB ao dispositivo:

```bash
# 1. Verificar conectividade b√°sica
adb shell ping -c 3 8.8.8.8

# 2. Tentar resolver DNS
adb shell nslookup cdccreditsmart.com

# 3. Verificar se consegue fazer HTTP
adb shell curl -I https://cdccreditsmart.com/api/health

# 4. Limpar cache DNS do Android
adb shell su -c "ndc resolver clearnetcache"

# 5. Verificar configura√ß√£o de rede
adb shell dumpsys connectivity

# 6. For√ßar usar DNS Google
adb shell settings put global private_dns_mode hostname
adb shell settings put global private_dns_specifier dns.google

# 7. Ver logs em tempo real
adb logcat | grep -E "MdmCommandReceiver|WebSocketManager|DNS"
```

---

## ‚úÖ CHECKLIST DE RESOLU√á√ÉO

### 1. Verificar Ambiente
- [ ] WiFi/Dados m√≥veis est√£o ativos?
- [ ] Outros apps conectam na internet?
- [ ] Navegador abre `https://cdccreditsmart.com`?

### 2. Verificar APK
- [ ] Permiss√£o `INTERNET` no AndroidManifest?
- [ ] `network_security_config` configurado?
- [ ] DNS customizado implementado?

### 3. Implementar Fallbacks
- [ ] Polling HTTP funcionando (n√£o depende de WebSocket)?
- [ ] Retry logic com backoff exponencial?
- [ ] Cache DNS local?

### 4. Diagn√≥stico
- [ ] Executar `runFullDiagnostics()` e ver logs
- [ ] Testar com DNS p√∫blico (8.8.8.8)
- [ ] Verificar firewall/VPN no dispositivo

### 5. Solu√ß√£o Tempor√°ria
- [ ] Implementar IP direto como fallback?
- [ ] Notificar usu√°rio sobre problema de rede?

---

## üîÑ SISTEMA DE POLLING (ALTERNATIVA AO WEBSOCKET)

Enquanto o WebSocket n√£o funciona, o APK deve **priorizar polling HTTP**:

```kotlin
class MdmPollingService(
    private val apiService: ApiService,
    private val deviceId: String,
    private val authToken: String
) {
    
    private val pollingScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private var pollingJob: Job? = null
    private val pollingInterval = 30_000L // 30 segundos
    
    fun startPolling() {
        Log.i("MdmPolling", "üîÑ Iniciando polling de comandos MDM (${pollingInterval/1000}s)")
        
        pollingJob?.cancel()
        pollingJob = pollingScope.launch {
            while (isActive) {
                try {
                    fetchAndExecuteCommands()
                } catch (e: Exception) {
                    Log.e("MdmPolling", "‚ùå Erro no polling: ${e.message}", e)
                }
                
                delay(pollingInterval)
            }
        }
    }
    
    private suspend fun fetchAndExecuteCommands() {
        try {
            Log.d("MdmPolling", "üì° Buscando comandos MDM...")
            
            val response = apiService.getCommands(deviceId)
            
            if (response.isSuccessful) {
                val commands = response.body()?.commands ?: emptyList()
                
                if (commands.isEmpty()) {
                    Log.d("MdmPolling", "‚úÖ Nenhum comando pendente")
                } else {
                    Log.i("MdmPolling", "üì• ${commands.size} comandos recebidos")
                    
                    commands.forEach { command ->
                        executeCommand(command)
                    }
                }
            } else {
                Log.e("MdmPolling", "‚ùå Erro HTTP: ${response.code()} ${response.message()}")
            }
            
        } catch (e: UnknownHostException) {
            Log.e("MdmPolling", "‚ùå DNS n√£o resolve - verificar conectividade")
        } catch (e: IOException) {
            Log.e("MdmPolling", "‚ùå Erro de rede: ${e.message}")
        } catch (e: Exception) {
            Log.e("MdmPolling", "‚ùå Erro inesperado: ${e.message}", e)
        }
    }
    
    private suspend fun executeCommand(command: MdmCommand) {
        Log.i("MdmPolling", "‚öôÔ∏è Executando comando: ${command.commandType} (${command.id})")
        
        val result = try {
            when (command.commandType) {
                "BLOCK_APPS_PROGRESSIVE" -> blockAppsProgressive(command)
                "UNBLOCK_APPS_PROGRESSIVE" -> unblockAppsProgressive(command)
                "LOCK_SCREEN" -> lockDevice(command)
                else -> {
                    Log.w("MdmPolling", "‚ö†Ô∏è Comando desconhecido: ${command.commandType}")
                    CommandResult(success = false, error = "Comando n√£o reconhecido")
                }
            }
        } catch (e: Exception) {
            Log.e("MdmPolling", "‚ùå Falha ao executar ${command.commandType}: ${e.message}", e)
            CommandResult(success = false, error = e.message)
        }
        
        // Enviar ACK ao backend
        sendAck(command.id, result)
    }
    
    private suspend fun sendAck(commandId: String, result: CommandResult) {
        try {
            val ackRequest = AckRequest(
                status = if (result.success) "completed" else "failed",
                result = result
            )
            
            val response = apiService.acknowledgeCommand(deviceId, commandId, ackRequest)
            
            if (response.isSuccessful) {
                Log.i("MdmPolling", "‚úÖ ACK enviado com sucesso para comando $commandId")
            } else {
                Log.e("MdmPolling", "‚ùå Falha ao enviar ACK: ${response.code()}")
            }
            
        } catch (e: Exception) {
            Log.e("MdmPolling", "‚ùå Erro ao enviar ACK: ${e.message}", e)
        }
    }
    
    fun stopPolling() {
        Log.i("MdmPolling", "üõë Parando polling de comandos MDM")
        pollingJob?.cancel()
        pollingJob = null
    }
}
```

---

## üìû SUPORTE T√âCNICO

**Pr√≥ximos passos:**

1. Executar `runFullDiagnostics()` no APK e enviar logs completos
2. Testar DNS p√∫blico (Solu√ß√£o 1)
3. Verificar se navegador abre `https://cdccreditsmart.com` no dispositivo
4. Se nada funcionar: usar IP direto temporariamente (Solu√ß√£o 2)

**Informa√ß√µes para reportar:**
- Modelo do dispositivo: Moto G15 Power
- Vers√£o do Android: [?]
- Tipo de rede: WiFi ou Dados m√≥veis?
- Provedor de internet: [?]
- Logs completos do diagn√≥stico

---

**√öltima atualiza√ß√£o:** 11 de Novembro de 2025
**Vers√£o do documento:** 1.0.0
**Sistema:** CDC CreditSmart APK - Connectivity Troubleshooting
