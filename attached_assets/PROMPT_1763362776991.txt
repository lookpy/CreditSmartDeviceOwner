# Atualiza√ß√£o do APK - Sistema de Verifica√ß√£o de Conformidade

## ‚ö†Ô∏è IMPORTANTE: APK Precisa Ser Atualizado

O backend agora possui um sistema de verifica√ß√£o de conformidade que garante que dispositivos n√£o escapem do bloqueio progressivo. Para funcionar corretamente, o APK precisa reportar seu estado atual de bloqueio.

---

## üîß O Que Precisa Ser Implementado no APK

### 1. Expandir Payload do Heartbeat

**Endpoint:** `POST /api/apk/device/:serialNumber/heartbeat`

**ANTES (payload antigo - ainda funciona mas n√£o verifica conformidade):**
```json
{
  "batteryLevel": 85,
  "networkType": "WiFi",
  "appVersion": "1.2.3"
}
```

**DEPOIS (payload novo - RECOMENDADO):**
```json
{
  "batteryLevel": 85,
  "networkType": "WiFi",
  "appVersion": "1.2.3",
  
  // üÜï NOVOS CAMPOS DE BLOQUEIO
  "currentBlockLevel": 5,              // N√≠vel atual de bloqueio (0-6)
  "blockedAppsCount": 12,              // Quantidade de apps bloqueados
  "lockScreenActive": true,            // Se a tela de bloqueio est√° ativa
  "progressiveBlockActive": true,      // Se o bloqueio progressivo est√° ativo
  "blockedCategories": ["social", "games"]  // Categorias bloqueadas (opcional)
}
```

### 2. Processar Resposta do Heartbeat

**Resposta do Backend:**
```json
{
  "success": true,
  "complianceStatus": "OK" | "NON_COMPLIANT" | "UNKNOWN",
  "expectedBlockLevel": 5,
  "message": "Device compliant"
}
```

**Como Processar:**

```kotlin
// Enviar heartbeat expandido
val heartbeat = JSONObject().apply {
    put("batteryLevel", getBatteryLevel())
    put("networkType", getNetworkType())
    put("appVersion", BuildConfig.VERSION_NAME)
    
    // üÜï Adicionar dados de bloqueio
    put("currentBlockLevel", getCurrentBlockLevel())
    put("blockedAppsCount", getBlockedAppsCount())
    put("lockScreenActive", isLockScreenActive())
    put("progressiveBlockActive", isProgressiveBlockActive())
}

val response = sendHeartbeat(serialNumber, heartbeat)

// Processar resposta
when (response.getString("complianceStatus")) {
    "OK" -> {
        // ‚úÖ Dispositivo est√° conforme - tudo ok
        Log.d(TAG, "Dispositivo conforme com n√≠vel ${response.getInt("expectedBlockLevel")}")
    }
    
    "NON_COMPLIANT" -> {
        // ‚ùå Dispositivo N√ÉO est√° conforme
        // Backend detectou que o n√≠vel reportado n√£o corresponde ao esperado
        val expectedLevel = response.getInt("expectedBlockLevel")
        
        Log.w(TAG, "‚ö†Ô∏è N√ÉO CONFORME! Esperado: $expectedLevel, Atual: ${getCurrentBlockLevel()}")
        
        // A√á√ÉO RECOMENDADA: For√ßar aplica√ß√£o do n√≠vel correto
        applyProgressiveBlock(expectedLevel)
    }
    
    "UNKNOWN" -> {
        // ‚ÑπÔ∏è Backend n√£o conseguiu verificar (sem dados de refer√™ncia)
        // Continuar opera√ß√£o normal
    }
}
```

---

## üìã Implementa√ß√£o Passo a Passo

### Passo 1: Adicionar M√©todos para Obter Estado de Bloqueio

```kotlin
class DeviceBlockManager {
    
    /**
     * Obt√©m o n√≠vel atual de bloqueio progressivo (0-6)
     */
    fun getCurrentBlockLevel(): Int {
        // Retornar o n√≠vel atual salvo em SharedPreferences
        return sharedPrefs.getInt("current_block_level", 0)
    }
    
    /**
     * Conta quantos apps est√£o bloqueados atualmente
     */
    fun getBlockedAppsCount(): Int {
        val blockedApps = sharedPrefs.getStringSet("blocked_apps", emptySet())
        return blockedApps?.size ?: 0
    }
    
    /**
     * Verifica se a tela de bloqueio est√° ativa
     */
    fun isLockScreenActive(): Boolean {
        return sharedPrefs.getBoolean("lock_screen_active", false)
    }
    
    /**
     * Verifica se o bloqueio progressivo est√° ativo
     */
    fun isProgressiveBlockActive(): Boolean {
        val currentLevel = getCurrentBlockLevel()
        return currentLevel > 0
    }
    
    /**
     * Retorna categorias bloqueadas (opcional)
     */
    fun getBlockedCategories(): List<String> {
        // Ex: ["social", "games", "entertainment"]
        return sharedPrefs.getStringSet("blocked_categories", emptySet())?.toList() ?: emptyList()
    }
}
```

### Passo 2: Atualizar M√©todo de Heartbeat

```kotlin
class HeartbeatService : Service() {
    
    private val blockManager = DeviceBlockManager(this)
    
    private fun sendHeartbeat() {
        try {
            val payload = JSONObject().apply {
                // Dados existentes
                put("batteryLevel", getBatteryLevel())
                put("networkType", getNetworkType())
                put("appVersion", BuildConfig.VERSION_NAME)
                
                // üÜï Dados de bloqueio
                put("currentBlockLevel", blockManager.getCurrentBlockLevel())
                put("blockedAppsCount", blockManager.getBlockedAppsCount())
                put("lockScreenActive", blockManager.isLockScreenActive())
                put("progressiveBlockActive", blockManager.isProgressiveBlockActive())
                
                // Opcional
                val categories = blockManager.getBlockedCategories()
                if (categories.isNotEmpty()) {
                    put("blockedCategories", JSONArray(categories))
                }
            }
            
            // Enviar para backend
            val response = apiClient.post(
                url = "/api/apk/device/$serialNumber/heartbeat",
                body = payload
            )
            
            // Processar resposta
            handleComplianceResponse(response)
            
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao enviar heartbeat", e)
        }
    }
    
    private fun handleComplianceResponse(response: JSONObject) {
        val complianceStatus = response.getString("complianceStatus")
        val expectedLevel = response.optInt("expectedBlockLevel", 0)
        
        when (complianceStatus) {
            "NON_COMPLIANT" -> {
                Log.w(TAG, "‚ö†Ô∏è Dispositivo n√£o conforme! Corrigindo bloqueio...")
                
                // For√ßar aplica√ß√£o do n√≠vel correto
                blockManager.applyProgressiveBlock(expectedLevel)
                
                // Enviar outro heartbeat ap√≥s corre√ß√£o para confirmar
                Handler(Looper.getMainLooper()).postDelayed({
                    sendHeartbeat()
                }, 5000) // 5 segundos depois
            }
            
            "OK" -> {
                Log.d(TAG, "‚úÖ Dispositivo conforme - N√≠vel $expectedLevel")
            }
        }
    }
}
```

### Passo 3: Garantir Persist√™ncia do Estado

```kotlin
class DeviceBlockManager {
    
    /**
     * Aplicar bloqueio progressivo e SALVAR o n√≠vel
     */
    fun applyProgressiveBlock(level: Int) {
        Log.d(TAG, "Aplicando bloqueio progressivo - N√≠vel $level")
        
        // 1. Salvar n√≠vel atual
        sharedPrefs.edit()
            .putInt("current_block_level", level)
            .apply()
        
        // 2. Aplicar bloqueios conforme o n√≠vel
        when (level) {
            0 -> {
                removeAllBlocks()
                sharedPrefs.edit()
                    .putBoolean("lock_screen_active", false)
                    .putBoolean("progressive_block_active", false)
                    .apply()
            }
            1 -> {
                blockCamera()
                updateBlockedApps(listOf("camera"))
            }
            2 -> {
                blockCamera()
                blockWiFi()
                updateBlockedApps(listOf("camera", "wifi"))
            }
            3 -> {
                blockCamera()
                blockWiFi()
                blockSocialMediaApps()
                updateBlockedApps(getSocialMediaPackages())
            }
            4 -> {
                blockCamera()
                blockWiFi()
                blockSocialMediaApps()
                activateLockScreen()
                sharedPrefs.edit()
                    .putBoolean("lock_screen_active", true)
                    .apply()
            }
            5, 6 -> {
                applyMaximumBlock(level)
                sharedPrefs.edit()
                    .putBoolean("lock_screen_active", true)
                    .putBoolean("progressive_block_active", true)
                    .apply()
            }
        }
        
        Log.d(TAG, "‚úÖ Bloqueio n√≠vel $level aplicado e salvo")
    }
    
    private fun updateBlockedApps(packages: List<String>) {
        sharedPrefs.edit()
            .putStringSet("blocked_apps", packages.toSet())
            .putInt("blocked_apps_count", packages.size)
            .apply()
    }
}
```

---

## ‚úÖ Checklist de Implementa√ß√£o

- [ ] **Adicionar m√©todos para obter estado de bloqueio**
  - `getCurrentBlockLevel()`
  - `getBlockedAppsCount()`
  - `isLockScreenActive()`
  - `isProgressiveBlockActive()`

- [ ] **Expandir payload do heartbeat**
  - Incluir `currentBlockLevel`
  - Incluir `blockedAppsCount`
  - Incluir `lockScreenActive`
  - Incluir `progressiveBlockActive`

- [ ] **Processar resposta do heartbeat**
  - Verificar `complianceStatus`
  - Corrigir bloqueio quando `NON_COMPLIANT`
  - Reenviar heartbeat ap√≥s corre√ß√£o

- [ ] **Garantir persist√™ncia**
  - Salvar n√≠vel atual em `SharedPreferences`
  - Atualizar contador de apps bloqueados
  - Atualizar flags de estado

- [ ] **Testar conformidade**
  - Aplicar bloqueio e verificar heartbeat
  - Simular n√£o conformidade (alterar n√≠vel manualmente)
  - Verificar se backend detecta e corrige

---

## üß™ Como Testar

### Teste 1: Conformidade Normal
```
1. Backend envia comando: N√≠vel 5
2. APK aplica bloqueio n√≠vel 5
3. APK envia heartbeat com currentBlockLevel: 5
4. Backend responde: complianceStatus: "OK"
‚úÖ Teste passou
```

### Teste 2: N√£o Conformidade (Detec√ß√£o de Bypass)
```
1. Backend envia comando: N√≠vel 5
2. APK aplica bloqueio n√≠vel 5
3. Usu√°rio tenta burlar e remove bloqueio (n√≠vel volta para 0)
4. APK envia heartbeat com currentBlockLevel: 0
5. Backend responde: complianceStatus: "NON_COMPLIANT", expectedBlockLevel: 5
6. APK detecta n√£o conformidade e corrige, aplicando n√≠vel 5 novamente
7. APK envia novo heartbeat com currentBlockLevel: 5
8. Backend responde: complianceStatus: "OK"
‚úÖ Dispositivo n√£o conseguiu escapar do bloqueio!
```

### Teste 3: APK Antigo (Compatibilidade)
```
1. APK antigo envia heartbeat SEM currentBlockLevel
2. Backend responde: complianceStatus: "UNKNOWN"
3. APK continua funcionando normalmente
‚úÖ Compatibilidade mantida
```

---

## üìä Benef√≠cios

‚úÖ **Seguran√ßa Total**: Dispositivos n√£o podem escapar do bloqueio  
‚úÖ **Detec√ß√£o Autom√°tica**: Backend detecta tentativas de bypass  
‚úÖ **Corre√ß√£o Autom√°tica**: APK corrige bloqueio quando detectado  
‚úÖ **Audit Trail**: Todas as n√£o conformidades s√£o registradas  
‚úÖ **Compat√≠vel**: APKs antigos continuam funcionando  

---

## üö® Importante

- **N√£o √© obrigat√≥rio atualizar imediatamente** - APKs antigos continuam funcionando
- **Recomendado atualizar** para obter verifica√ß√£o de conformidade completa
- **Backend j√° est√° preparado** - s√≥ esperando o APK reportar os dados
- **Sem breaking changes** - mudan√ßa √© apenas adicional, n√£o quebra c√≥digo existente

---

## üí¨ D√∫vidas?

Se tiver qualquer d√∫vida sobre a implementa√ß√£o, consulte:
- `SISTEMA_VERIFICACAO_CONFORMIDADE_IMPLEMENTADO.md` - Documenta√ß√£o completa do backend
- Endpoint de heartbeat: `/api/apk/device/:serialNumber/heartbeat`
- Logs do backend mostram exatamente o que est√° sendo recebido
