# ü§ñ PROMPT PARA IA - Desenvolvimento APK Kotlin

## Contexto
Voc√™ est√° desenvolvendo um aplicativo Android em Kotlin para o sistema CDC Credit Smart, uma plataforma fintech de vendas de dispositivos com cr√©dito. O APK precisa se integrar com o backend para realizar pareamento seguro de dispositivos vendidos.

## Objetivo
Implementar o **fluxo completo de pareamento APK-PDV** seguindo a documenta√ß√£o t√©cnica fornecida no arquivo `APK_INTEGRATION_DOCUMENTATION.md`.

---

## üìã TAREFAS PRINCIPAIS

### 1. **Leitura e Valida√ß√£o de IMEI**

Implemente a leitura do IMEI do dispositivo com as seguintes caracter√≠sticas:

```kotlin
// Requisitos:
- Usar TelephonyManager para ler IMEI
- Suportar Android 5.0 (API 21) at√© Android 14+ (API 34)
- Validar formato: 15-17 d√≠gitos num√©ricos
- Implementar fallback para dispositivos sem IMEI (tablets)
- Fun√ß√£o cleanImei() para remover caracteres n√£o-num√©ricos
```

**M√©todo esperado:**
```kotlin
fun getDeviceImei(context: Context): String
```

---

### 2. **Scanner de QR Code**

Implemente scanner de QR Code que:

```kotlin
// Requisitos:
- Use biblioteca ML Kit ou ZXing
- Extraia o contractId do formato: "CTR_timestamp_imei"
- Valide formato do QR Code
- Mostre preview da c√¢mera
- Retorne resultado via callback ou LiveData
```

**M√©todo esperado:**
```kotlin
fun scanQRCode(activity: Activity, onResult: (String) -> Unit)
```

---

### 3. **C√°lculo de Device Fingerprint**

Implemente fun√ß√£o que calcula identificador √∫nico do dispositivo:

```kotlin
// Requisitos:
- Use SHA-256
- Combine: Build.SERIAL + Build.BRAND + Build.MODEL + IMEI
- Resultado: String hexadecimal (64 caracteres)
- Deve ser idempotente (mesmo resultado sempre)
```

**F√≥rmula:**
```kotlin
SHA256("${Build.SERIAL}${Build.BRAND}${Build.MODEL}${imei}")
```

**M√©todo esperado:**
```kotlin
fun calculateFingerprint(imei: String): String
```

---

### 4. **Coleta de Device Info**

Implemente fun√ß√£o que coleta informa√ß√µes do dispositivo:

```kotlin
// Dados necess√°rios:
data class DeviceInfo(
    val brand: String,          // Build.BRAND
    val model: String,          // Build.MODEL
    val manufacturer: String,   // Build.MANUFACTURER
    val androidVersion: String, // Build.VERSION.RELEASE
    val sdkInt: Int,           // Build.VERSION.SDK_INT
    val serialNumber: String,  // Build.SERIAL
    val buildId: String        // Build.ID
)
```

**M√©todo esperado:**
```kotlin
fun collectDeviceInfo(): DeviceInfo
```

---

### 5. **Handshake Step 1: Buscar Venda Pendente**

Implemente requisi√ß√£o GET para buscar venda:

```kotlin
// Endpoint: GET https://cdccreditsmart.com/api/device/claim-sale?imei={IMEI}

// Resposta esperada:
data class PendingSaleResponse(
    val success: Boolean,
    val found: Boolean,
    val validationId: String,
    val saleId: String,
    val customerName: String,
    val deviceModel: String,
    val biometrySessionId: String,
    val storeId: String,
    val customerCpf: String,
    val expiresIn: Int
)
```

**M√©todo esperado:**
```kotlin
suspend fun searchPendingSale(imei: String): Result<PendingSaleResponse>
```

**Regras:**
- Se `found = false`: mostrar erro "Dispositivo n√£o registrado"
- Se `found = true`: prosseguir para Step 2
- Timeout: 30 segundos
- Usar Coroutines (suspend function)

---

### 6. **Handshake Step 2: Reivindicar Venda**

Implemente requisi√ß√£o POST para reivindicar venda:

```kotlin
// Endpoint: POST https://cdccreditsmart.com/api/device/claim-sale

// Request body:
data class ClaimRequest(
    val validationId: String,
    val hardwareImei: String,
    val fingerprint: String,
    val deviceInfo: DeviceInfo
)

// Response:
data class ClaimResponse(
    val success: Boolean,
    val matched: Boolean,
    val deviceId: String?,
    val deviceToken: String?,
    val apkToken: String?,
    val contractCode: String?,
    val customerCpf: String?,
    val message: String,
    val securityViolation: Boolean?,
    val attemptsRemaining: Int?
)
```

**M√©todo esperado:**
```kotlin
suspend fun claimSale(
    validationId: String,
    hardwareImei: String,
    fingerprint: String,
    deviceInfo: DeviceInfo
): Result<ClaimResponse>
```

**Regras:**
- Se `matched = false`: mostrar erro com tentativas restantes
- Se `securityViolation = true` e `attemptsRemaining = 0`: bloquear app
- Se `success = true` e `matched = true`: salvar tokens e prosseguir

---

### 7. **Armazenamento Seguro de Tokens**

Implemente armazenamento criptografado dos tokens:

```kotlin
// Requisitos:
- Use EncryptedSharedPreferences
- Salve: deviceToken, apkToken, fingerprint, contractCode
- Implemente getToken() e saveToken()
- Use MasterKey com AES256_GCM
```

**M√©todos esperados:**
```kotlin
fun saveTokens(deviceToken: String, apkToken: String, fingerprint: String)
fun getDeviceToken(): String?
fun getApkToken(): String?
fun clearTokens()
```

---

### 8. **WebSocket - Conex√£o em Tempo Real**

Implemente cliente WebSocket:

```kotlin
// URL: wss://cdccreditsmart.com/ws/flow-status

// Requisitos:
- Use OkHttp WebSocket
- Implementar autentica√ß√£o com contractId
- Implementar heartbeat (ping/pong a cada 30s)
- Reconex√£o autom√°tica em caso de falha
- Processar eventos: device_connected, sale_completed, error
```

**Classe esperada:**
```kotlin
class WebSocketManager(
    private val contractCode: String,
    private val onDeviceConnected: () -> Unit,
    private val onSaleCompleted: (data: SaleData) -> Unit,
    private val onError: (message: String) -> Unit
) {
    fun connect()
    fun disconnect()
    fun send(message: String)
}
```

**Mensagens para enviar:**

1. **Autentica√ß√£o** (imediatamente ap√≥s conex√£o):
```json
{
  "type": "authenticate",
  "contractId": "CTR_1762630954593_560533"
}
```

2. **Heartbeat** (a cada 30 segundos):
```json
{
  "type": "ping"
}
```

**Mensagens para receber:**

- `authenticated`: Confirma√ß√£o de autentica√ß√£o
- `device_connected`: Dispositivo conectado ao sistema
- `sale_completed`: Venda finalizada com sucesso
- `error`: Erro na comunica√ß√£o
- `pong`: Resposta ao ping

---

### 9. **Tratamento de Erros e Retry Logic**

Implemente estrat√©gias de retry:

```kotlin
// Requisitos:
- Retry com backoff exponencial: 1s, 2s, 4s, 8s
- M√°ximo 3 tentativas para requests HTTP
- Tratamento espec√≠fico para c√≥digos HTTP:
  * 429 (Rate Limit): aguardar 15 minutos
  * 500-599: retry com backoff
  * 400-499: n√£o fazer retry (erro do cliente)
```

**Fun√ß√£o esperada:**
```kotlin
suspend fun <T> retryWithBackoff(
    maxRetries: Int = 3,
    initialDelay: Long = 1000L,
    factor: Double = 2.0,
    block: suspend () -> T
): Result<T>
```

---

### 10. **UI/UX - Telas Principais**

Implemente as seguintes telas:

#### **Tela 1: Scanner QR Code**
- Preview da c√¢mera em fullscreen
- Indicador de √°rea de escaneamento
- Bot√£o "Cancelar"
- Feedback visual ao detectar QR Code

#### **Tela 2: Pareamento em Progresso**
- Loading spinner
- Texto: "Conectando dispositivo..."
- Progresso: "Validando IMEI..." ‚Üí "Verificando dados..." ‚Üí "Conectando..."
- N√£o cancel√°vel

#### **Tela 3: Sucesso**
- √çcone de sucesso (‚úì verde)
- Texto: "Dispositivo ativado com sucesso!"
- Mostrar: Nome do cliente, Modelo do dispositivo, C√≥digo do contrato
- Bot√£o: "Continuar"

#### **Tela 4: Erro**
- √çcone de erro (‚úó vermelho)
- Mensagem de erro espec√≠fica
- Para IMEI mismatch: mostrar tentativas restantes
- Bot√µes: "Tentar Novamente" (se tentativas > 0) ou "Contatar Suporte"

---

### 11. **Seguran√ßa e Valida√ß√µes**

Implemente as seguintes valida√ß√µes:

```kotlin
// 1. Valida√ß√£o de IMEI
fun isValidImeiFormat(imei: String): Boolean {
    val cleaned = imei.replace(Regex("[^0-9]"), "")
    return cleaned.length in 15..17
}

// 2. Contador de tentativas
class AttemptCounter {
    private val maxAttempts = 3
    private var attempts = 0
    
    fun increment(): Int
    fun getRemainingAttempts(): Int
    fun isBlocked(): Boolean
}

// 3. Bloqueio de dispositivo
fun blockDevice(reason: String) {
    // Salvar flag de bloqueio
    // Mostrar tela de bloqueio permanente
    // Impedir uso do app
}
```

---

## üîß DEPEND√äNCIAS NECESS√ÅRIAS

Adicione ao `build.gradle` (app):

```gradle
dependencies {
    // HTTP & WebSocket
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
    
    // Coroutines
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3'
    
    // JSON
    implementation 'org.json:json:20231013'
    
    // Security
    implementation 'androidx.security:security-crypto:1.1.0-alpha06'
    
    // QR Code Scanner
    implementation 'com.google.mlkit:barcode-scanning:17.2.0'
    // OU
    implementation 'com.journeyapps:zxing-android-embedded:4.3.0'
    
    // Lifecycle
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.7.0'
}
```

**Permiss√µes no AndroidManifest.xml:**
```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<uses-permission android:name="android.permission.CAMERA" />

<uses-feature android:name="android.hardware.camera" android:required="true" />
```

---

## üì± FLUXO COMPLETO DE USO (Ponto de Vista do Usu√°rio)

1. **Usu√°rio abre app** ap√≥s comprar dispositivo na loja
2. **App solicita permiss√µes**: C√¢mera, Telefone
3. **Usu√°rio toca** em "Escanear QR Code"
4. **C√¢mera abre** e usu√°rio aponta para QR Code no PDV
5. **App detecta** QR Code e extrai contractId
6. **App automaticamente**:
   - L√™ IMEI do hardware
   - Busca venda pendente (Step 1)
   - Envia dados do dispositivo (Step 2)
   - Conecta via WebSocket
7. **Tela mostra**: "Conectando dispositivo..."
8. **Backend valida** IMEI e retorna tokens
9. **App salva** tokens de forma segura
10. **WebSocket notifica**: "Dispositivo conectado"
11. **Tela mostra**: "‚úì Dispositivo ativado com sucesso!"
12. **Usu√°rio** pode usar o dispositivo normalmente

---

## ‚ö†Ô∏è CASOS DE ERRO A TRATAR

### Erro 1: IMEI N√£o Coincide
```kotlin
// Cen√°rio: APK envia IMEI diferente do registrado no PDV
// A√ß√£o: Mostrar erro + tentativas restantes
// Se tentativas = 0: bloquear dispositivo permanentemente
```

### Erro 2: Venda N√£o Encontrada
```kotlin
// Cen√°rio: IMEI n√£o tem venda pendente no sistema
// A√ß√£o: Mostrar "Dispositivo n√£o registrado. Verifique com a loja."
```

### Erro 3: Valida√ß√£o Expirada
```kotlin
// Cen√°rio: Prazo de 24h expirou
// A√ß√£o: Mostrar "Prazo expirado. Entre em contato com a loja."
```

### Erro 4: Rate Limit Excedido
```kotlin
// Cen√°rio: Muitas tentativas em pouco tempo
// A√ß√£o: Desabilitar bot√£o "Tentar Novamente" por 15 minutos
```

### Erro 5: Sem Internet
```kotlin
// Cen√°rio: Dispositivo offline
// A√ß√£o: Mostrar "Sem conex√£o. Verifique sua internet."
```

### Erro 6: Timeout
```kotlin
// Cen√°rio: Requisi√ß√£o demora >30s
// A√ß√£o: Mostrar "Tempo esgotado. Tente novamente."
```

---

## üß™ TESTES RECOMENDADOS

### Teste 1: Fluxo Feliz
- Escanear QR Code v√°lido
- IMEI correto
- Pareamento bem-sucedido
- ‚úÖ Esperado: Dispositivo ativado

### Teste 2: IMEI Incorreto
- Escanear QR Code v√°lido
- Modificar IMEI antes de enviar
- ‚ùå Esperado: Erro + tentativas restantes

### Teste 3: IMEI Bloqueado
- Fazer 3 tentativas com IMEI errado
- ‚ùå Esperado: Dispositivo bloqueado permanentemente

### Teste 4: QR Code Inv√°lido
- Escanear QR Code aleat√≥rio
- ‚ùå Esperado: Erro "QR Code inv√°lido"

### Teste 5: Sem Internet
- Desativar WiFi e dados m√≥veis
- Tentar escanear QR Code
- ‚ùå Esperado: Erro "Sem conex√£o"

### Teste 6: Reconex√£o WebSocket
- Conectar WebSocket
- Desconectar internet por 10s
- Reconectar internet
- ‚úÖ Esperado: WebSocket reconecta automaticamente

---

## üìö REFER√äNCIA R√ÅPIDA DE ENDPOINTS

| M√©todo | Endpoint | Descri√ß√£o |
|--------|----------|-----------|
| GET | `/api/device/claim-sale?imei={IMEI}` | Buscar venda pendente |
| POST | `/api/device/claim-sale` | Reivindicar venda |
| POST | `/api/device/claim-sale/legacy` | Endpoint legacy (compatibilidade) |
| GET | `/api/device/{fingerprint}/status` | Status do dispositivo |
| POST | `/api/device/{fingerprint}/refresh` | Refresh de token |
| WS | `wss://cdccreditsmart.com/ws/flow-status` | WebSocket tempo real |

---

## üéØ CRIT√âRIOS DE SUCESSO

Seu c√≥digo ser√° considerado completo quando:

- ‚úÖ Conseguir escanear QR Code do PDV
- ‚úÖ Ler IMEI do dispositivo corretamente
- ‚úÖ Realizar handshake completo (Step 1 + Step 2)
- ‚úÖ Salvar tokens de forma segura
- ‚úÖ Conectar via WebSocket e receber eventos
- ‚úÖ Tratar todos os casos de erro documentados
- ‚úÖ Bloquear dispositivo ap√≥s 3 tentativas de IMEI incorreto
- ‚úÖ Reconectar WebSocket automaticamente
- ‚úÖ Mostrar UI clara para cada estado (loading, sucesso, erro)

---

## üí° DICAS DE IMPLEMENTA√á√ÉO

### Dica 1: Estrutura de Arquivos
```
app/src/main/java/com/cdccreditsmart/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ DeviceInfo.kt
‚îÇ   ‚îú‚îÄ‚îÄ PendingSaleResponse.kt
‚îÇ   ‚îî‚îÄ‚îÄ ClaimResponse.kt
‚îú‚îÄ‚îÄ network/
‚îÇ   ‚îú‚îÄ‚îÄ ApiClient.kt
‚îÇ   ‚îú‚îÄ‚îÄ WebSocketManager.kt
‚îÇ   ‚îî‚îÄ‚îÄ RetryPolicy.kt
‚îú‚îÄ‚îÄ security/
‚îÇ   ‚îú‚îÄ‚îÄ FingerprintCalculator.kt
‚îÇ   ‚îî‚îÄ‚îÄ SecureStorage.kt
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îú‚îÄ‚îÄ QRScannerActivity.kt
‚îÇ   ‚îú‚îÄ‚îÄ PairingActivity.kt
‚îÇ   ‚îî‚îÄ‚îÄ SuccessActivity.kt
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ ImeiValidator.kt
    ‚îî‚îÄ‚îÄ AttemptCounter.kt
```

### Dica 2: Use ViewModel
```kotlin
class PairingViewModel : ViewModel() {
    private val _pairingState = MutableLiveData<PairingState>()
    val pairingState: LiveData<PairingState> = _pairingState
    
    fun pairDevice(qrCode: String) {
        viewModelScope.launch {
            _pairingState.value = PairingState.Loading
            // ... l√≥gica de pareamento
        }
    }
}

sealed class PairingState {
    object Loading : PairingState()
    data class Success(val contractCode: String) : PairingState()
    data class Error(val message: String, val attemptsRemaining: Int?) : PairingState()
}
```

### Dica 3: Logging
```kotlin
// Use Timber ou Android Log
Log.d("Pairing", "Step 1: Searching pending sale for IMEI: $imei")
Log.d("Pairing", "Step 2: Claiming sale with validationId: $validationId")
Log.e("Pairing", "Error: ${error.message}")
```

---

## üìÑ DOCUMENTA√á√ÉO COMPLETA

Consulte o arquivo `APK_INTEGRATION_DOCUMENTATION.md` para:
- Detalhes t√©cnicos completos de cada endpoint
- Estruturas de dados JSON
- Exemplos de c√≥digo Kotlin
- Diagramas de fluxo
- Troubleshooting avan√ßado

---

## üöÄ COME√áE AQUI

1. Leia o arquivo `APK_INTEGRATION_DOCUMENTATION.md` completo
2. Configure as depend√™ncias no `build.gradle`
3. Adicione permiss√µes no `AndroidManifest.xml`
4. Implemente na seguinte ordem:
   - ‚úÖ Leitura de IMEI
   - ‚úÖ Scanner QR Code
   - ‚úÖ C√°lculo de Fingerprint
   - ‚úÖ Handshake Step 1
   - ‚úÖ Handshake Step 2
   - ‚úÖ Armazenamento de Tokens
   - ‚úÖ WebSocket
   - ‚úÖ UI/UX
   - ‚úÖ Tratamento de Erros

Boa sorte! üéâ
